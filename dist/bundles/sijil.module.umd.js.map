{"version":3,"file":"sijil.module.umd.js","sources":["../../src/services/require/httprequire.service.ts","../../src/services/require/require.interface.ts","../../src/services/parser/parser.interface.ts","../../src/services/parser/fragments.parser.ts","../../src/services/bundles.service.ts","../../src/services/sijil.opts.ts","../../src/components/s5l.component.ts","../../src/pipes/translate.pipe.ts","../../src/sijil.module.ts"],"sourcesContent":["import { RequireService } from './require.interface'\nimport { Injectable } from '@angular/core'\nimport { Http } from '@angular/http'\n\n/**\n * Fetches a bundle from a target url.\n * \n * @export\n * @class HttpRequireService\n * @implements {RequireService}\n */\n@Injectable()\nexport class HttpRequireService implements RequireService {\n\n    constructor(private http: Http){}\n\n    load(url) : Promise<Object> {\n        return this.http.get(url).toPromise()\n            .then(data => data.json())\n    }\n\n}","/**\n * Service used to fetch bundles.\n * \n * @export\n * @abstract\n * @class RequireService\n */\nexport abstract class RequireService {\n    /**\n     * Fetch a bundle. \n     * @memberOf RequireService\n     */\n    load: (from: any) => Promise<Object>\n}","export class ParserError extends Error {\n    constructor(public message: string, public fragment: string) {\n        super(message)\n    }\n}\n\nexport type ParserCallback = (_ : ParserError) => string\n/**\n * Parses logic inside translations.\n * \n * @export\n * @abstract\n * @class Parser\n */\nexport abstract class Parser {\n    /**\n     * Processes a string, isolating logic fragments and compiling them.\n     * \n     * @memberOf Parser\n     */\n    compile: (text: string, parameters: any, error?: ParserCallback) => string\n}","import { Parser, ParserCallback, ParserError } from './parser.interface'\n\n/**\n * The default Sijil parser.\n *\n * - Input : bundle value (translation) + parameters (Object or Array)\n * - Output : compiled translation\n *\n * Logic is contained inside mustache blocks : {{ LOGIC BLOCK }}\n *\n * There are two variants :\n *  - A single parameter key (when the params are contained inside an object) or index (params contained inside an array)\n *\n * Examples:\n *\n * {{ key }} + { \"key\" : \"my key\" } = my key\n *\n * {{ 1 }} + [1, 2] = 2\n *\n *  - A ternary-like condition\n *\n * {{ condition ? trueValue : falseValue }}\n * Where condition may be : a single parameter key/index, or 2 clauses with the following operators : ==, >, =>, <=, <\n *\n * Examples:\n *\n * (the $ sign to refer to a variable is mandatory when a clause contains more than 1 word)\n *\n * {{ count > 1 ? $count cats : 1 cat }} + {\"count\": 10} = 10 cats\n * {{ 1 < count ? $count cats : 1 cat }} + {\"count\": 1} = 1 cat\n *\n * @export\n * @class FragmentsParser\n * @implements {Parser}\n */\nexport class FragmentsParser implements Parser {\n\n    constructor(){}\n\n    private static delimiters: string[] = ['{{', '}}']\n    private static delimRegexp = new RegExp(`${FragmentsParser.delimiters[0]}[^}]+${FragmentsParser.delimiters[1]}`, 'gm')\n\n    private static defaultErrorCallback : ParserCallback = (e: ParserError) => {\n        console.error(e)\n        return e.fragment\n    }\n\n    private getParameter(parameters: Object | any[], fragment: string, strict?: boolean) : string {\n        let splittedFrag = fragment.split(/\\s+/)\n        if(splittedFrag.length === 1) {\n            return fragment[0] === \"$\" ?\n                parameters[fragment.substr(1)] :\n                strict ?\n                    fragment :\n                    parameters[fragment] !== undefined ?\n                        parameters[fragment] :\n                        fragment\n        }\n        return fragment.split(/\\s+/).reduce((l, r) => {\n            l.push(r[0] === \"$\" ? parameters[r.substr(1)] : r)\n            return l\n        }, []).join(' ')\n    }\n\n    private compileFragment(fragment: string, parameters: Object | any[]): string {\n        fragment = fragment.replace(/{{|}}/g, '')\n\n        let interrogationIndex, dotsIndex\n        if ((interrogationIndex = fragment.indexOf('?')) > 0 && (dotsIndex = fragment.lastIndexOf(':')) > 1) {\n            let condition = fragment.substring(0, interrogationIndex).trim()\n            let trueReturn = fragment.substring(interrogationIndex + 1, dotsIndex).trim()\n            let falseReturn = fragment.substring(dotsIndex + 1).trim()\n            let computedTrueReturn = this.getParameter(parameters, trueReturn)\n            let computedFalseReturn = this.getParameter(parameters, falseReturn)\n\n            let splittedCondition = condition.split(/\\s+/)\n\n            if (splittedCondition.length === 1) {\n\n                // Single variable case\n\n                let variable = parameters[splittedCondition[0]]\n\n                return variable ?\n                    computedTrueReturn :\n                    computedFalseReturn\n\n            } else if (splittedCondition.length === 3) {\n\n                // Operator case\n\n                let leftHandParam = this.getParameter(parameters, splittedCondition[0], parameters instanceof Array)\n                let rightHand = this.getParameter(parameters, splittedCondition[2], parameters instanceof Array)\n                let comparisonOperator = splittedCondition[1]\n\n                switch (comparisonOperator) {\n                    case '==':\n                        return leftHandParam == rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '>':\n                        return leftHandParam > rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '>=':\n                        return leftHandParam >= rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '<':\n                        return leftHandParam < rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '<=':\n                        return leftHandParam <= rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    default:\n                        throw new ParserError(`Invalid conditional operator for fragment : ${fragment}`, fragment)\n                }\n\n            } else {\n                throw new ParserError(`Invalid condition for fragment : ${fragment}`, fragment)\n            }\n        } else {\n            fragment = fragment.trim()\n            return parameters[fragment]\n        }\n    }\n\n    compile(rawTranslation: string, parameters: Object, onError?: ParserCallback): string {\n\n        let parts = rawTranslation.split(FragmentsParser.delimRegexp)\n        let fragments = rawTranslation.match(FragmentsParser.delimRegexp)\n\n        let compiledTranslation = \"\"\n\n        if (!onError)\n            onError = FragmentsParser.defaultErrorCallback\n\n        if (!fragments) {\n            compiledTranslation += rawTranslation\n        } else {\n            for (let i = 0; i < parts.length; i++) {\n                compiledTranslation += parts[i]\n                if (i > fragments.length - 1)\n                    continue\n                try {\n                    compiledTranslation += this.compileFragment(fragments[i], parameters)\n                } catch (e) {\n                    compiledTranslation += onError(e)\n                }\n            }\n        }\n\n        return compiledTranslation\n\n    }\n\n}","import { RequireService, SijilOpts, Parser } from './index'\n\n/**\n * Defines a BundlesService, whice is the main entry point for Sijil operations.\n *\n * A BundlesServices has three dependencies :\n * - RequireService : Used to fetch bundles\n * - Parser : Used to parse logic inside bundle values\n * - SijilOpts : An object containing custom settings\n */\nexport class BundlesService {\n\n    constructor(private requireService: RequireService, private parser: Parser, sijilOpts: SijilOpts) {\n        this.defaultLanguage = sijilOpts.defaultLanguage\n        if(!this.defaultLanguage && typeof window !== 'undefined'){\n            this.defaultLanguage = window.navigator.language.split('-')[0]\n        }\n        this.currentLanguage = this.defaultLanguage\n    }\n\n    private bundles: Object = {}\n    /**\n     * Fallback language.\n     */\n    defaultLanguage : string\n    /**\n     * Current language.\n     */\n    currentLanguage : string\n\n    /**\n     * Add keys/values to an existing bundle, or create it if missing.\n     *\n     * @param {Object} bundle An object containing translations as key / values.\n     * @param {string} [lang] The language to map the bundle with, or the current langugage if omitted.\n     */\n    addToBundle(bundle: Object, lang?: string) : void {\n        let targetLanguage = lang || this.currentLanguage || this.defaultLanguage || 'en'\n\n        if(!this.bundles[targetLanguage])\n            this.bundles[targetLanguage] = {}\n\n        let newBundle = {}\n        let oldBundle = {}\n\n        for(let key in bundle) {\n            newBundle[key] = bundle[key]\n        }\n        for(let key in oldBundle){\n            newBundle[key] = oldBundle[key]\n        }\n\n        this.bundles[targetLanguage] = newBundle\n\n        if(!this.currentLanguage)\n            this.currentLanguage = lang\n    }\n\n    /**\n     * Loads a bundle and associates it with a language.\n     * If the target language already contains key/values, then we mixin the new bundle and the existing one.\n     *\n     * @param {any} where The path, or whatever the RequireService needs to fetch the bundle.\n     * @param {string} [lang] The target language, or the current language if omitted.\n     * @returns {Promise<void>} A Promise, because the RequireService can be (is - by default) asynchronous.\n     */\n    loadBundle(where, lang?: string) : Promise<void> {\n        return this.requireService.load(where)\n            .then(bundle => {\n                this.addToBundle(bundle, lang)\n            })\n    }\n    /**\n     * Loads multiple bundles and associates then with a language.\n     *\n     * @see {@link loadBundle}\n     */\n    loadBundles(specs: { lang: string, where: any }[]): Promise<void[]> {\n        return Promise.all(specs.map((spec) => {\n            return this.loadBundle(spec.where, spec.lang)\n        }))\n    }\n\n    /**\n     * Removes a bundle from the bundles list.\n     *\n     * @param {string} lang Language to remove.\n     */\n    unloadBundle(lang: string) : void {\n        delete this.bundles[lang]\n    }\n\n    /**\n     * @returns {string[]} Returns a list of all loaded languages.\n     */\n    getLoadedLanguages() : string[] {\n        return Object.keys(this.bundles)\n    }\n\n    /**\n     * Translates a single key into a target language, using the parameters provided if needed.\n     *\n     * @param {string} key Key to translate\n     * @param {(Object | any[])} [parameters] Parameters to use if the translation contains logic.\n     * @param {string} [lang] Target language, of the current language if omitted.\n     * @returns {string} The computed translation, or the key if no match was found in the bundles (including the fallback language bundle).\n     */\n    translate(key: string, parameters?: Object | any[], lang?: string) : string {\n        let targetLanguage = lang || this.currentLanguage\n\n        let rawTranslation : string = this.bundles[targetLanguage] &&\n            this.bundles[targetLanguage][key] ||\n            this.defaultLanguage &&\n            this.bundles[this.defaultLanguage] &&\n            this.bundles[this.defaultLanguage][key] ||\n            key\n\n        if(rawTranslation !== key && parameters) {\n            return this.parser.compile(rawTranslation, parameters, (e) => { console.error(e); return key })\n        } else {\n            return rawTranslation\n        }\n\n    }\n\n}","/**\n * Contains Sijil options.\n *\n * @export\n * @abstract\n * @class SijilOpts\n */\nexport abstract class SijilOpts {\n    /** Fallback language when a translation is not available in the current language. */\n    defaultLanguage: string\n}\n\nexport let defaultSijilOpts : SijilOpts = {\n    defaultLanguage: window ? window.navigator.language.split('-')[0] : undefined\n}","import { Component, Input, ElementRef, ViewChild, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core'\nimport { BundlesService } from '../services'\n\n@Component({\n    selector: 's5l',\n    template: `\n    <span #wrapper>\n        <ng-content></ng-content>\n    </span>`,\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class S5lComponent implements AfterViewInit {\n\n    constructor(private bundlesService: BundlesService){}\n\n    @ViewChild(\"wrapper\") wrapperRef: ElementRef\n\n    private value: string\n    private loaded: boolean\n\n    @Input(\"s5l-params\") parameters: Object | any[]\n    @Input(\"s5l-lang\") fixedLanguage: string\n\n    private refreshTranslation() {\n        this.wrapperRef.nativeElement.innerHTML = this.bundlesService.translate(this.value, this.parameters, this.fixedLanguage)\n    }\n\n    ngAfterViewInit() : void {\n        this.value = this.wrapperRef.nativeElement.innerHTML.trim()\n        this.loaded = true\n        this.refreshTranslation()\n    }\n\n    ngDoCheck() {\n        if (!this.loaded)\n            return\n        this.refreshTranslation()\n    }\n}","import { BundlesService } from '../services';\nimport { Pipe, PipeTransform } from '@angular/core'\n\n@Pipe({name: 'translate', pure: false})\nexport class TranslatePipe {\n\n    constructor(private bundlesService: BundlesService){}\n\n    transform(key: string, parameters?: Object | any[], lang?: string) : string {\n        return this.bundlesService.translate(key, parameters, lang)\n    }\n\n}","import { NgModule, ModuleWithProviders, Type } from '@angular/core'\nimport { HttpModule } from '@angular/http'\n\nimport { S5lComponent } from './components'\nimport { TranslatePipe } from './pipes/translate.pipe'\nimport { HttpRequireService, RequireService, BundlesService,\n    SijilOpts, defaultSijilOpts, Parser, FragmentsParser } from './services/index'\nimport './rxjs-includes'\n\n/**\n * Sijil angular2 module.\n *\n * Usage :\n *\n * ```typescript\n * import { SijilModule } from 'sijil/dist'\n *\n * @NgModule({\n *   imports: [\n *       // ... //\n *      SijilModule\n *       // ... //\n *    ]\n * })\n * ```\n */\n@NgModule({\n    imports: [ HttpModule ],\n    declarations: [ S5lComponent, TranslatePipe ],\n    providers: [],\n    exports: [ S5lComponent, TranslatePipe ]\n})\nexport class SijilModule {\n\n    static forRoot(require?: Type<RequireService>, parser?: Type<Parser>, options?: SijilOpts) : ModuleWithProviders {\n        return {\n            ngModule: SijilModule,\n            providers: [\n                { provide: BundlesService, useClass: BundlesService, deps: [ RequireService, Parser, SijilOpts ] },\n                { provide: RequireService, useClass: require || HttpRequireService },\n                { provide: Parser, useClass: parser || FragmentsParser },\n                { provide: SijilOpts, useValue: options || defaultSijilOpts }\n            ]\n        }\n    }\n\n    static forChild() : ModuleWithProviders {\n        return {\n            ngModule: SijilModule,\n            providers: []\n        }\n    }\n\n}"],"names":["exports","http","this","HttpRequireService","url","get","toPromise","then","data","json","Injectable","Http","message","fragment","_super","_this","__extends","Error","FragmentsParser","parameters","strict","splittedFrag","split","length","substr","undefined","reduce","l","r","push","join","replace","interrogationIndex","dotsIndex","indexOf","lastIndexOf","trim","condition","substring","trueReturn","falseReturn","computedTrueReturn","getParameter","computedFalseReturn","splittedCondition","variable","ParserError","leftHandParam","Array","rightHand","comparisonOperator","rawTranslation","onError","parts","delimRegexp","fragments","match","compiledTranslation","defaultErrorCallback","i","compileFragment","e","RegExp","delimiters","console","error","requireService","parser","sijilOpts","defaultLanguage","window","navigator","language","currentLanguage","BundlesService","bundle","lang","targetLanguage","bundles","newBundle","oldBundle","key","where","load","addToBundle","specs","Promise","all","map","spec","loadBundle","Object","keys","compile","defaultSijilOpts","S5lComponent","bundlesService","wrapperRef","nativeElement","innerHTML","translate","value","fixedLanguage","loaded","refreshTranslation","__decorate","ViewChild","ElementRef","Input","Component","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","TranslatePipe","Pipe","name","pure","SijilModule","require","options","ngModule","SijilModule_1","providers","provide","useClass","deps","RequireService","Parser","SijilOpts","useValue","NgModule","imports","HttpModule","declarations"],"mappings":"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"}