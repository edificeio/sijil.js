{"version":3,"file":null,"sources":["../../src/services/bundles.service.ts","../../src/services/parser/parser.interface.ts","../../src/services/parser/fragments.parser.ts","../../src/services/require/xhrrequire.service.ts","../../src/services/sijil.opts.ts","../../src/sijil.ts"],"sourcesContent":["import { RequireService, SijilOpts, Parser } from './index'\n\n/**\n * Defines a BundlesService, whice is the main entry point for Sijil operations.\n * \n * A BundlesServices has three dependencies :\n * - RequireService : Used to fetch bundles\n * - Parser : Used to parse logic inside bundle values\n * - SijilOpts : An object containing custom settings\n */\nexport class BundlesService {\n\n    constructor(private requireService: RequireService, private parser: Parser, sijilOpts: SijilOpts) {\n        this.defaultLanguage = sijilOpts.defaultLanguage || window.navigator.language.split('-')[0]\n        this.currentLanguage = this.defaultLanguage\n    }\n\n    private bundles: Object = {}\n    /**\n     * Fallback language.\n     */\n    defaultLanguage : string\n    /**\n     * Current language.\n     */\n    currentLanguage : string\n\n    /**\n     * Add keys/values to an existing bundle, or create it if missing.\n     * \n     * @param {Object} bundle An object containing translations as key / values.\n     * @param {string} [lang] The language to map the bundle with, or the current langugage if omitted. \n     */\n    addToBundle(bundle: Object, lang?: string) : void {\n        let targetLanguage = lang || this.currentLanguage\n\n        if(!this.bundles[targetLanguage])\n            this.bundles[targetLanguage] = {}\n\n        for(let key in bundle) {\n            this.bundles[targetLanguage][key] = bundle[key]\n        }\n    }\n\n    /**\n     * Loads a bundle and associates it with a language.\n     * If the target language already contains key/values, then we mixin the new bundle and the existing one.\n     * \n     * @param {any} where The path, or whatever the RequireService needs to fetch the bundle.\n     * @param {string} [lang] The target language, or the current language if omitted.\n     * @returns {Promise<void>} A Promise, because the RequireService can be (is - by default) asynchronous.\n     */\n    loadBundle(where, lang?: string) : Promise<void> {\n        return this.requireService.load(where)\n            .then(bundle => {\n                this.addToBundle(bundle, lang)\n            })\n    }\n    /**\n     * Loads multiple bundles and associates then with a language.\n     * \n     * @see {@link loadBundle}\n     */\n    loadBundles(specs: { lang: string, where: any }[]): Promise<void[]> {\n        return Promise.all(specs.map((spec) => {\n            return this.loadBundle(spec.where, spec.lang)\n        }))\n    }\n\n    /**\n     * Removes a bundle.\n     * \n     * @param {string} lang Language to remove.\n     */\n    unloadBundle(lang: string) : void {\n        delete this.bundles[lang]\n    }\n\n    /**\n     * @returns {string[]} Returns a list of all loaded languages.\n     */\n    getLoadedLanguages() : string[] {\n        return Object.keys(this.bundles)\n    }\n\n    /**\n     * Translates a single key, using the parameters provided in a target language.\n     * \n     * @param {string} key Key to translate\n     * @param {(Object | any[])} [parameters] Parameters to use if the translation contains logic.\n     * @param {string} [lang] Target language, of the current language if omitted.\n     * @returns {string} The computed translation, or the key if no match was found in the bundles (including the fallback language bundle).\n     */\n    translate(key: string, parameters?: Object | any[], lang?: string) : string {\n        let targetLanguage = lang || this.currentLanguage\n        \n        let rawTranslation : string = this.bundles[targetLanguage] &&\n            this.bundles[targetLanguage][key] ||\n            this.defaultLanguage &&\n            this.bundles[this.defaultLanguage] && \n            this.bundles[this.defaultLanguage][key] ||\n            key\n\n        if(rawTranslation !== key && parameters) {\n            return this.parser.compile(rawTranslation, parameters, (e) => { console.error(e); return key })\n        } else {\n            return rawTranslation\n        }\n\n    }\n\n}","export class ParserError extends Error {\n    constructor(public message: string, public fragment: string) {\n        super(message)\n    }\n}\n\nexport type ParserCallback = (_ : ParserError) => string\n/**\n * Parses logic inside translations.\n * \n * @export\n * @abstract\n * @class Parser\n */\nexport abstract class Parser {\n    /**\n     * Processes a string, isolating logic fragments and compiling them.\n     * \n     * @memberOf Parser\n     */\n    compile: (text: string, parameters: any, error?: ParserCallback) => string\n}","import { Parser, ParserCallback, ParserError } from './parser.interface'\n\n/**\n * The default Sijil parser.\n * \n * - Input : bundle value (translation) + parameters (Object or Array)\n * - Output : compiled translation\n * \n * Logic is contained inside mustache blocks : {{ LOGIC BLOCK }}\n * \n * There are two variants :\n *  - A single parameter key (when the params are contained inside an object) or index (params contained inside an array)\n *      \n * Examples: \n * \n * {{ key }} + { \"key\" : \"my key\" } = my key \n * \n * {{ 1 }} + [1, 2] = 2\n * \n *  - A ternary-like condition\n *      \n * {{ condition ? trueValue : falseValue }}\n * Where condition may be : a single parameter key/index, or 2 clauses with the following operators : ==, >, =>, <=, < \n * \n * Examples: \n * \n * (the $ sign to refer to a variable is mandatory when a clause contains more than 1 word)\n * \n * {{ count > 1 ? $count cats : 1 cat }} + {\"count\": 10} = 10 cats\n * {{ 1 < count ? $count cats : 1 cat }} + {\"count\": 1} = 1 cat\n * \n * @export\n * @class FragmentsParser\n * @implements {Parser}\n */\nexport class FragmentsParser implements Parser {\n\n    constructor(){}\n\n    private static delimiters: string[] = ['{{', '}}']\n    private static delimRegexp = new RegExp(`${FragmentsParser.delimiters[0]}[^}]+${FragmentsParser.delimiters[1]}`, 'gm')\n\n    private static defaultErrorCallback : ParserCallback = (e: ParserError) => {\n        console.error(e)\n        return e.fragment\n    }\n\n    private getParameter(parameters: Object | any[], fragment: string) : string {\n        let splittedFrag = fragment.split(/\\s+/)\n        if(splittedFrag.length === 1) {\n            return fragment[0] === \"$\" ? parameters[fragment.substr(1)] : parameters[fragment] || fragment\n        }\n        return fragment.split(/\\s+/).reduce((l, r) => {\n            l.push(r[0] === \"$\" ? parameters[r.substr(1)] : r)\n            return l\n        }, []).join(' ')\n    }\n\n    private compileFragment(fragment: string, parameters: Object | any[]): string {\n        fragment = fragment.replace(/{{|}}/g, '')\n\n        let interrogationIndex, dotsIndex\n        if ((interrogationIndex = fragment.indexOf('?')) > 0 && (dotsIndex = fragment.lastIndexOf(':')) > 1) {\n            let condition = fragment.substring(0, interrogationIndex).trim()\n            let trueReturn = fragment.substring(interrogationIndex + 1, dotsIndex).trim()\n            let falseReturn = fragment.substring(dotsIndex + 1).trim()\n            let computedTrueReturn = this.getParameter(parameters, trueReturn)\n            let computedFalseReturn = this.getParameter(parameters,falseReturn)\n\n            let splittedCondition = condition.split(/\\s+/)\n\n            if (splittedCondition.length === 1) {\n                // Single variable case\n                let variable = parameters[splittedCondition[0]]\n\n                return variable ?\n                    computedTrueReturn :\n                    computedFalseReturn\n            } else if (splittedCondition.length === 3) {\n                // Operator case\n                let leftHandParam = parameters[splittedCondition[0]] || splittedCondition[0]\n                let rightHand = parameters[splittedCondition[2]] || splittedCondition[2]\n                let comparisonOperator = splittedCondition[1]\n\n                switch (comparisonOperator) {\n                    case '==':\n                        return leftHandParam == rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '>':\n                        return leftHandParam > rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '>=':\n                        return leftHandParam >= rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '<':\n                        return leftHandParam < rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    case '<=':\n                        return leftHandParam <= rightHand ?\n                            computedTrueReturn :\n                            computedFalseReturn\n                    default:\n                        throw new ParserError(`Invalid conditional operator for fragment : ${fragment}`, fragment)\n                }\n            } else {\n                throw new ParserError(`Invalid condition for fragment : ${fragment}`, fragment)\n            }\n        } else {\n            fragment = fragment.trim()\n            return parameters[fragment]\n        }\n    }\n\n    compile(rawTranslation: string, parameters: Object, onError?: ParserCallback): string {\n\n        let parts = rawTranslation.split(FragmentsParser.delimRegexp)\n        let fragments = rawTranslation.match(FragmentsParser.delimRegexp)\n\n        let compiledTranslation = \"\"\n\n        if (!onError)\n            onError = FragmentsParser.defaultErrorCallback\n\n        if (!fragments) {\n            compiledTranslation += rawTranslation\n        } else {\n            for (let i = 0; i < parts.length; i++) {\n                compiledTranslation += parts[i]\n                if (i > fragments.length - 1)\n                    continue\n                try {\n                    compiledTranslation += this.compileFragment(fragments[i], parameters)\n                } catch (e) {\n                    compiledTranslation += onError(e)\n                }\n            }\n        }\n\n        return compiledTranslation\n\n    }\n\n}","import { RequireService } from './require.interface'\n\nexport class XHRRequire implements RequireService {\n    \n    load(from: string, async?: boolean) : Promise<Object>{\n        return new Promise((resolve, reject) => {\n            let request = new XMLHttpRequest()\n\n            request.open('GET', from, !async)\n            request.responseType = \"json\"\n            request.onload = function(e) {\n                if(request.status === 200){\n                    let json = request.response\n                    resolve(json)\n                } else {\n                    console.log('Unsupported language.')\n                }\n            }\n            request.onerror = function(e) {\n                console.error(e)\n            }\n            request.send()\n        })\n    }\n\n}","/**\n * Contains Sijil options.\n * \n * @export\n * @abstract\n * @class SijilOpts\n */\nexport abstract class SijilOpts {\n    /** Fallback language when a translation is not available in the current language. */\n    defaultLanguage: string\n}\n\nexport let defaultSijilOpts : SijilOpts = {\n    defaultLanguage: window.navigator.language.split('-')[0]\n}","import { BundlesService } from './services/bundles.service'\nimport { RequireService}   from './services/require/require.interface'\nimport { FragmentsParser } from './services/parser/fragments.parser'\nimport { Parser } from './services/parser/parser.interface'\nimport { XHRRequire } from './services/require/xhrrequire.service'\nimport { defaultSijilOpts, SijilOpts } from './services/sijil.opts'\n\nlet bundlesService = new BundlesService(new XHRRequire(), new FragmentsParser(), defaultSijilOpts)\nbundlesService['factory'] = (require: RequireService, parser: Parser, opts: SijilOpts) => {\n    return new BundlesService(require || new XHRRequire(), parser || new FragmentsParser(), opts || defaultSijilOpts)\n}\nexport default bundlesService"],"names":["requireService","parser","sijilOpts","this","defaultLanguage","window","navigator","language","split","currentLanguage","BundlesService","bundle","lang","targetLanguage","bundles","key","where","load","then","_this","addToBundle","specs","Promise","all","map","spec","loadBundle","Object","keys","parameters","rawTranslation","compile","e","console","error","message","fragment","_super","__extends","Error","FragmentsParser","splittedFrag","length","substr","reduce","l","r","push","join","replace","interrogationIndex","dotsIndex","indexOf","lastIndexOf","trim","condition","substring","trueReturn","falseReturn","computedTrueReturn","getParameter","computedFalseReturn","splittedCondition","variable","ParserError","leftHandParam","rightHand","comparisonOperator","onError","parts","delimRegexp","fragments","match","compiledTranslation","defaultErrorCallback","i","compileFragment","RegExp","delimiters","XHRRequire","from","async","resolve","reject","request","XMLHttpRequest","open","responseType","onload","status","json","response","log","onerror","send","defaultSijilOpts","bundlesService","require","opts"],"mappings":"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"}